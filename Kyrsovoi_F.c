#include <stdio.h>
#include <locale.h>
#include <stdlib.h>

int** zap_sobstv(int** A, int s1, int k1);						// функция для собственного заполнения матрицы
int** random(int** A, int d, int s1, int k1);					// функция для заполнения матрицы с помощью генератора случайных чисел
int** proizvedenie(int** A, int** B, int s1, int k1, int k2);	// функция перемножения матриц
void print(int** A, int s1, int k1);							// функция вывода матриц
void sort_rascheska(int** C, int s3, int k3);					// сортировка расческой по возрастанию элементов диагонали матрицы

int main() {
	setlocale(LC_ALL, "RUS");

	puts("\t****************************************************************************************");
	puts("\t*                                 Курсовой проект                                      *");
	puts("\t*                                                                                      *");
	puts("\t*                        Подготовил студент группы: бИД-242                            *");
	puts("\t*                           Пивоварова Алёна Анатольевна                               *");
	puts("\t*                                                                                      *");
	puts("\t*                       Задание: даны два двумерных массива                            *");
	puts("\t*          Перемножить их как матрицы. Результат записать в третий массив.             *");
	puts("\t*                 Получившийся массив отсортировать методом расчески                   *");
	puts("\t*              (сортировка элементов главной диагонали по возрастанию)                 *");
	puts("\t****************************************************************************************");
	
	while (1) {
		char o;
		int rang; /* максимально возможная размерность массива. */
		printf("\tВведите размерность массива:  ");
		scanf_s("%d", &rang);

		int s1, s2, k1, k2; /* s1, s2 - количество строк в матрицах; k1, k2 - количество столбцов в матрицах.*/
		printf("\n\tВведите количество строк первой матрицы:  ");
		scanf_s("%d", &s1);
		printf("\n\tВведите количество столбцов первой матрицы:  ");
		scanf_s("%d", &k1);

		if ((s1 > rang) || (k1 > rang)) {
			printf("\n\n\t\tВы ввели параметры превышающие максимальную размерность, попробуйте снова!\n");
			continue;
		}

		printf("\n\tВведите количество строк второй матрицы:  ");
		scanf_s("%d", &s2);
		printf("\n\tВведите количество столбцов второй матрицы:  ");
		scanf_s("%d", &k2);

		if ((s2 > rang) || (k2 > rang)) { /* минимальная размерность не должна превосходить ранг матрицы */
			printf("\n\n\t\tВы ввели параметры превышающие максимальную размерность, попробуйте снова!\n");
			continue;
		}

		int** A = (int**)malloc(s1 * sizeof(int*));		/* выделение памяти под первый массив */
		for (int i = 0; i < s1; i++) {
			A[i] = (int*)malloc(k1 * sizeof(int));
		}
		if (A == NULL) {
			puts("Технические шоколадки");
			return -1;
		}

		int** B = (int**)malloc(s2 * sizeof(int*));		
		for (int i = 0; i < s2; i++) {
			B[i] = (int*)malloc(k2 * sizeof(int));
		}
		if (B == NULL) {
			puts("Технические шоколадки");
			return -1;
		}

		if (k1 != s2) {	/*проверка выполнения условия умножения матриц */
			printf("\n\tКоличество столбцов первой матрицы не совпадает с количеством строк второй матрицы: \n\tУМНОЖЕНИЕ НЕВОЗМОЖНО\n");
			for (int i = 0; i < s1; i++) {	// Освобождение памяти, если матрицы нельзя перемножить
				free(A[i]);
			}
			free(A);
			for (int i = 0; i < s2; i++) {
				free(B[i]);
			}
			free(B);
			continue; 
		}
		else {
			printf("\n\t\tУмножение возможно! \n\n");
		}

		int spsb, end, d; /*spsb - способ заполнения, end - сповоб вывода, d - диапазон для генерации случайных чисел.*/
		printf("\n\tВыберете способ инициализации массивов: \n\t\t 1 - собственноручно; \n\t\t 2 - с помощью генерации случайных чисел\n\t\t\t");
		scanf_s("%d", &spsb);
		printf("\n\tВыберете способ вывода результата: \n\t\t 1 - только новый, получившийся в результате умножения массив; \n\t\t 2 - все три массива;\n\t\t\t");
		scanf_s("%d", &end);

		switch (spsb) {	/* инициализация по выбору пользователя */
		case 1:
			puts("\n\t\tВведите первую матрицу:   \n");
			zap_sobstv(A, s1, k1); 
			printf("\n");

			puts("\n\tВведите вторую матрицу:   \n");
			zap_sobstv(B, s2, k2); 
			printf("\n");
			break;

		case 2:
			puts("\n\tВведите максимальное значение диапазона > 1:  ");
			scanf_s("%d", &d);

			random(A, d, s1, k1); 
			random(B, d, s2, k2); 
			break;
		default:
			printf("Произошли технические шоколадки, попробуйте ещё раз!");
			break;
		}

		int** C = proizvedenie(A, B, s1, k1, k2); /*функция перемножения матриц*/

		switch (end) {	/*вывод результатов по выбору пользователя*/
		case 1:
			printf("\n\t\tРезультат: \n\n");
			print(C, s1, k2);

			break;
		case 2:
			printf("\n\t\tПервая матрица: \n\n");
			print(A, s1, k1);

			printf("\n");

			printf("\n\t\tВторая матрица: \n\n");
			print(B, s2, k2);

			printf("\n");

			printf("\n\t\tРезультат: \n\n");
			print(C, s1, k2);

			break;
		default:
			printf("Произошли технические шоколадки, попробуйте ещё раз!");
			break;
		}

		printf("\n\t\tОтсортированный массив: \n\n");
		sort_rascheska(C, s1, k2);
		print(C, s1, k2);

		for (int i = 0; i < s1; i++) {		/* Освобождение памяти */
			free(A[i]);
		}
		free(A);
		for (int i = 0; i < s2; i++) {
			free(B[i]);
		}
		free(B);
		for (int i = 0; i < s1; i++) {
			free(C[i]);
		}
		free(C);
		printf("\n");

		printf("Продолжить ? (Да - y, нет - n)  ");
		o = getchar();

		if (o == 'n') {
			break;
		}
	}
}

int** zap_sobstv(int** A, int s1, int k1) {
	for (int i = 0; i < s1; i++) {			// функция предназначена для того, чтобы 
		for (int j = 0; j < k1; j++) {		// пользователь мог самостоятельно инициализировать
			printf(" a[%d][%d] = ", i, j);	// элементы массива с консоли
			scanf_s("\n%d", &A[i][j]);
		}
	}
	return A;
}

int** random(int** A, int d, int s1, int k1) {
	for (int i = 0; i < s1; i++) {					// функция предназначена для того, чтобы
		for (int j = 0; j < k1; j++) {				// массив инициализировался случайными
			A[i][j] = -d + rand() % (d - (-d));		// сгенерированными числами
		}
	}
	return A;
}

int** proizvedenie(int** A, int** B, int s1, int k1, int k2) {

	int s3 = s1; /* кол - во строк в новой матрице = кол - ву строк первой матрицы */
	int k3 = k2; /* кол - во столбцов в новой матрице = кол - ву столбцов второй матрицы */

	int** C = (int**)malloc(s3 * sizeof(int*));		// функция предназначена для того, чтобы
	for (int i = 0; i < s1; i++) {					// перемножать массивы (матрицы) и записывать результат в новый массив
		C[i] = (int*)malloc(k3 * sizeof(int));
		if (C[i] == NULL) {
			return NULL;
		}
	}
	
	for (int i = 0; i < s3; i++){
		for (int j = 0; j < k3; j++) {			
			C[i][j] = 0;
			for (int k = 0; k < k1; k++) {
				C[i][j] += A[i][k] * B[k][j];
			}
		}
	}
	return C;
}

void print(int** A, int s1, int k1) {
	for (int i = 0; i < s1; i++) {			// функция предназначена для того, чтобы
		for (int j = 0; j < k1; j++) {		// массив выводился на экран 

			printf(" %3d ", A[i][j]); 
		}
		printf("\n");
	}
	return;
}

void sort_rascheska(int** C, int s3, int k3) {
	int size_d;			 // Количество элементов на главной диагонали  
	if (s3 < k3) {		 // определяется меньшим измерением матрицы
		size_d = s3;	 // (количеством строк или столбцов)
	}
	else {
		size_d = k3;
	}

	int* d = (int*)malloc(size_d * sizeof(int));
	if (d == NULL) {   	/* массив, в котором будут храниться элементы главной диагонали*/
		return;
	}
	for (int i = 0; i < size_d; i++) {
		d[i] = C[i][i];
	}
	int s = size_d;		 /* начальный шаг */
	int c;				 /* счетчик перестановок */
	while (s > 1) {
		s = s * 10 / 13; /* шаг при каждом проходе */ 
		if (s < 1) {
			s = 1;
		}
		c = 0;
		for (int i = 0; i < size_d - s; i++) {
			if (d[i] > d[i + s]) { 
				int t = d[i];
				d[i] = d[i + s];
				d[i + s] = t;
				c++;
			}
		}
		if (c = 0 && s == 1) {
			break;		/* остановка, если нет перестановок и при s == 1 */ 
		}
	}
	for (int i = 0; i < size_d; i++) {
		C[i][i] = d[i]; /* Заменяем элементы диагонали в исходной матрице */
	}
	free(d);			/* освобождаем память после использования */
	return;
}